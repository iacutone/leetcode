# Leetcode

## Intro

My attempt to get better a algorithms based on [this](https://seanprashad.com/leetcode-patterns/) blogpost.

According to the post, there are 180 identifiable patterns that FAANG use as determination for web application development skills to filter out applicants that either have better things to do with their time or are young and have the time available to invest learning leetcode algorithm patterns.

With practice, one can identify the patterns and ostensibly pass a FAANG interview.

<!-- livebook:{"break_markdown":true} -->

### 217. Contains Duplicate

Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct.

Example 1:

Input: nums = [1,2,3,1]

Output: true

Example 2:

Input: nums = [1,2,3,4]

Output: false

Example 3:

Input: nums = [1,1,1,3,3,4,3,2,4,2]

Output: true

```elixir
Enum.reduce_while([1, 2, 3, 4], MapSet.new(), fn num, acc ->
  if MapSet.member?(acc, num) do
    {:halt, true}
  else
    {:cont, MapSet.put(acc, num)}
  end
end)
|> case do
  true -> true
  _ -> false
end

# 08/05/2025
length([1, 2, 3, 1]) != [1, 2, 3, 1] |> Enum.uniq() |> length()
```

### 268. Missing Number

Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array.

Example 1:

Input: nums = [3,0,1]

Output: 2

Explanation: n = 3 since there are 3 numbers, so all numbers are in the range [0,3]. 2 is the missing number in the range since it does not appear in nums.

Example 2:

Input: nums = [0,1]

Output: 2

Explanation: n = 2 since there are 2 numbers, so all numbers are in the range [0,2]. 2 is the missing number in the range since it does not appear in nums.

Example 3:

Input: nums = [9,6,4,2,3,5,7,0,1]

Output: 8

Explanation: n = 9 since there are 9 numbers, so all numbers are in the range [0,9]. 8 is the missing number in the range since it does not appear in nums.

Constraints:

n == nums.length

1 <= n <= 104

0 <= nums[i] <= n

All the numbers of nums are unique.

Follow up: Could you implement a solution using only O(1) extra space complexity and O(n) runtime complexity?

```elixir
# (n * (n + 1)/2)

nums = [0]
size = length(nums)
sum = Enum.sum(nums)

size
|> :erlang.+(1)
|> :erlang./(2)
|> :erlang.*(size)
|> :erlang.-(sum)
|> round()

# 08/05/2020
n = length([9, 6, 4, 2, 3, 5, 7, 0, 1])
set = MapSet.new([9, 6, 4, 2, 3, 5, 7, 0, 1])

Enum.find(0..n, fn num ->
  !MapSet.member?(set, num)
end)
```

### 448. Find All Numbers Disappeared in an Array

Given an array nums of n integers where nums[i] is in the range [1, n], return an array of all the integers in the range [1, n] that do not appear in nums.

Example 1:

Input: nums = [4,3,2,7,8,2,3,1]

Output: [5,6]

Example 2:

Input: nums = [1,1]

Output: [2]

Constraints:

n == nums.length

1 <= n <= 105

1 <= nums[i] <= n

Follow up: Could you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space.

```elixir
nums = [4, 3, 2, 7, 8, 2, 3, 1]
```

### 121. Best Time to Buy and Sell Stock

You are given an array prices where prices[i] is the price of a given stock on the ith day.

You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.

Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.

Example 1:

Input: prices = [7,1,5,3,6,4]
Output: 5
Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.
Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.
Example 2:

Input: prices = [7,6,4,3,1]
Output: 0
Explanation: In this case, no transactions are done and the max profit = 0.

Constraints:

1 <= prices.length <= 105
0 <= prices[i] <= 104

```elixir
# as a map
prices = [7, 1, 5, 3, 6, 4]
price_map = %{min_price: List.first(prices), max_profit: 0}

result =
  Enum.reduce(prices, price_map, fn price,
                                    %{min_price: min_price, max_profit: max_profit} = acc ->
    acc = Map.put(acc, :min_price, min(price, min_price))
    Map.put(acc, :max_profit, max(max_profit, price - Map.get(acc, :min_price)))
  end)

Map.get(result, :max_profit)

# as a tuple
if length(prices) < 2 do
  0
else
  initial_state = {hd(prices), 0}

  {_min_price, max_profit} =
    Enum.reduce(tl(prices), initial_state, fn price, {min_price, max_profit} ->
      new_min_price = min(min_price, price)
      current_profit = price - new_min_price
      new_max_profit = max(max_profit, current_profit)
      {new_min_price, new_max_profit}
    end)

  max_profit
end
```

### 206. Reverse Linked List

Given the head of a singly linked list, reverse the list, and return the reversed list.

Example 1:

Input: head = [1,2,3,4,5]
Output: [5,4,3,2,1]
Example 2:

Input: head = [1,2]
Output: [2,1]
Example 3:

Input: head = []
Output: []

Constraints:

The number of nodes in the list is the range [0, 5000].
-5000 <= Node.val <= 5000

Follow up: A linked list can be reversed either iteratively or recursively. Could you implement both?

```elixir
defmodule ListNode do
  defstruct val: 0, next: nil
end

defmodule Solution do
  def reverse_list(nil), do: nil

  def reverse_list(list) do
    do_reverse_list(nil, list)
  end

  defp do_reverse_list(previous, nil), do: previous

  defp do_reverse_list(previous, current) do
    next_node = current.next
    new_current = %ListNode{val: current.val, next: previous}
    do_reverse_list(new_current, next_node)
  end
end
```

### 21. Merge Two Sorted Lists

You are given the heads of two sorted linked lists list1 and list2.

Merge the two lists into one sorted list. The list should be made by splicing together the nodes of the first two lists.

Return the head of the merged linked list.

Example 1:

Input: list1 = [1,2,4], list2 = [1,3,4]
Output: [1,1,2,3,4,4]
Example 2:

Input: list1 = [], list2 = []
Output: []
Example 3:

Input: list1 = [], list2 = [0]
Output: [0]

Constraints:

The number of nodes in both lists is in the range [0, 50].
-100 <= Node.val <= 100
Both list1 and list2 are sorted in non-decreasing order.

```elixir
defmodule ListNode do
  defstruct val: 0, next: nil
end

defmodule Solution do
  def merge_two_lists(list1, nil), do: list1
  def merge_two_lists(nil, list2), do: list2

  def merge_two_lists(list1, list2) do
    if list1.val <= list2.val do
      %ListNode{list1 | next: merge_two_lists(list1.next, list2)}
    else
      %ListNode{list2 | next: merge_two_lists(list1, list2.next)}
    end
  end
end
```

### 1. Two Sum

Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.

You may assume that each input would have exactly one solution, and you may not use the same element twice.

You can return the answer in any order.

Example 1:

Input: nums = [2,7,11,15], target = 9
Output: [0,1]
Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].
Example 2:

Input: nums = [3,2,4], target = 6
Output: [1,2]
Example 3:

Input: nums = [3,3], target = 6
Output: [0,1]

Constraints:

2 <= nums.length <= 104
-109 <= nums[i] <= 109
-109 <= target <= 109
Only one valid answer exists.

Follow-up: Can you come up with an algorithm that is less than O(n2) time complexity?

```elixir
nums = [2, 7, 11, 15]
target = 9

Enum.reduce_while(0..(length(nums) - 1), %{}, fn i, acc ->
  current_num = Enum.at(nums, i)
  complement = target - current_num

  if Map.has_key?(acc, complement) do
    {:halt, [Map.get(acc, complement), i]}
  else
    {:cont, Map.put(acc, current_num, i)}
  end
end)
```

### 283. Move Zeroes

Given an integer array nums, move all 0's to the end of it while maintaining the relative order of the non-zero elements.

Note that you must do this in-place without making a copy of the array.

Example 1:

Input: nums = [0,1,0,3,12]
Output: [1,3,12,0,0]
Example 2:

Input: nums = [0]
Output: [0]

Constraints:

1 <= nums.length <= 104
-231 <= nums[i] <= 231 - 1

Follow up: Could you minimize the total number of operations done?

```elixir
nums = [0, 1, 0, 3, 12]

{non_zeros, zeros} = Enum.split_with(nums, fn x -> x != 0 end)
non_zeros ++ zeros
```

### 20. Valid Parentheses

Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.

An input string is valid if:

Open brackets must be closed by the same type of brackets.
Open brackets must be closed in the correct order.
Every close bracket has a corresponding open bracket of the same type.

Example 1:

Input: s = "()"

Output: true

Example 2:

Input: s = "()[]{}"

Output: true

Example 3:

Input: s = "(]"

Output: false

Example 4:

Input: s = "([])"

Output: true

Example 5:

Input: s = "([)]"

Output: false

Constraints:

1 <= s.length <= 104
s consists of parentheses only '()[]{}'.

```elixir
s = "([])"

close_to_open_map = %{
  ")" => "(",
  "]" => "[",
  "}" => "{"
}

s
|> String.graphemes()
|> Enum.reduce([], fn char, stack ->
  case Map.get(close_to_open_map, char) do
    # char is an opening bracket
    nil ->
      [char | stack]

    open_bracket when stack != [] and hd(stack) == open_bracket ->
      # pop from the stack
      tl(stack)

    _ ->
      [:invalid | stack]
  end
end)
|> Enum.empty?()
```

### 238. Product of Array Except Self

Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].

The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.

You must write an algorithm that runs in O(n) time and without using the division operation.

Example 1:

Input: nums = [1,2,3,4]
Output: [24,12,8,6]
Example 2:

Input: nums = [-1,1,0,-3,3]
Output: [0,0,9,0,0]

Constraints:

2 <= nums.length <= 105
-30 <= nums[i] <= 30
The input is generated such that answer[i] is guaranteed to fit in a 32-bit integer.

Follow up: Can you solve the problem in O(1) extra space complexity? (The output array does not count as extra space for space complexity analysis.)

```elixir
# This solution times out on Leetcode
# Would need to implement with hard to grok
# prefix/postfix solution to pass Leetcode

nums = [1, 2, 3, 4]
# nums = [0, 0]

indexed_nums =
  nums
  |> Enum.with_index()
  |> Enum.into(%{}, fn {value, index} -> {index, value} end)

Enum.reduce(0..(length(nums) - 1), [], fn i, acc ->
  output =
    indexed_nums |> Map.delete(i) |> Map.values() |> Enum.reduce(1, fn n, acc -> n * acc end)

  [output | acc]
end)
|> Enum.reverse()
```

### 1047. Remove All Adjacent Duplicates In String

You are given a string s consisting of lowercase English letters. A duplicate removal consists of choosing two adjacent and equal letters and removing them.

We repeatedly make duplicate removals on s until we no longer can.

Return the final string after all such duplicate removals have been made. It can be proven that the answer is unique.

Example 1:

Input: s = "abbaca"
Output: "ca"
Explanation: 
For example, in "abbaca" we could remove "bb" since the letters are adjacent and equal, and this is the only possible move.  The result of this move is that the string is "aaca", of which only "aa" is possible, so the final string is "ca".
Example 2:

Input: s = "azxxzy"
Output: "ay"

Constraints:

1 <= s.length <= 105
s consists of lowercase English letters.

```elixir
s = "abbaca"

s
|> String.graphemes()
|> Enum.reduce([], fn char, stack ->
  case stack do
    [head | _] when head == char ->
      tl(stack)

    _ ->
      [char | stack]
  end
end)
|> Enum.reverse()
|> List.to_string()
```

### 14. Longest Common Prefix

Write a function to find the longest common prefix string amongst an array of strings.

If there is no common prefix, return an empty string "".

Example 1:

Input: strs = ["flower","flow","flight"]
Output: "fl"
Example 2:

Input: strs = ["dog","racecar","car"]
Output: ""
Explanation: There is no common prefix among the input strings.

Constraints:

1 <= strs.length <= 200
0 <= strs[i].length <= 200
strs[i] consists of only lowercase English letters if it is non-empty.

```elixir
strs = ["flower", "flow", "flight"]

defmodule LongestCommonPrefix do
  # recursive approach
  # def longest_common_prefix([]), do: ""
  # def longest_common_prefix([prefix | rest]) do
  #   Enum.reduce(rest, prefix, fn str, acc ->
  #     trim_prefix(str, acc)
  #   end)
  # end

  # defp trim_prefix(str, acc) do
  #   if String.starts_with?(str, acc) do
  #     acc
  #   else
  #     # Recursively trim the prefix by removing the last character
  #     trim_prefix(str, String.slice(acc, 0, String.length(acc) - 1))
  #   end
  # end

  # binary pattern matching recursive approach
  def longest_common_prefix([head | tail]) do
    Enum.reduce(tail, head, fn word, acc ->
      common_prefix(word, acc, "")
    end)
  end

  defp common_prefix(<<c, word_rest::binary>>, <<c, tail_rest::binary>>, common) do
    common_prefix(word_rest, tail_rest, common <> <<c>>)
  end

  defp common_prefix(_, _, common), do: common
end

LongestCommonPrefix.longest_common_prefix(strs)
```

### 706. Design HashMap

Design a HashMap without using any built-in hash table libraries.

Implement the MyHashMap class:

MyHashMap() initializes the object with an empty map.
void put(int key, int value) inserts a (key, value) pair into the HashMap. If the key already exists in the map, update the corresponding value.
int get(int key) returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key.
void remove(key) removes the key and its corresponding value if the map contains the mapping for the key.

Example 1:

Input
["MyHashMap", "put", "put", "get", "get", "put", "get", "remove", "get"]
[[], [1, 1], [2, 2], [1], [3], [2, 1], [2], [2], [2]]
Output
[null, null, null, 1, -1, null, 1, null, -1]

Explanation
MyHashMap myHashMap = new MyHashMap();
myHashMap.put(1, 1); // The map is now [[1,1]]
myHashMap.put(2, 2); // The map is now [[1,1], [2,2]]
myHashMap.get(1);    // return 1, The map is now [[1,1], [2,2]]
myHashMap.get(3);    // return -1 (i.e., not found), The map is now [[1,1], [2,2]]
myHashMap.put(2, 1); // The map is now [[1,1], [2,1]] (i.e., update the existing value)
myHashMap.get(2);    // return 1, The map is now [[1,1], [2,1]]
myHashMap.remove(2); // remove the mapping for 2, The map is now [[1,1]]
myHashMap.get(2);    // return -1 (i.e., not found), The map is now [[1,1]]

```elixir
defmodule MyHashMap do
  @bucket_size 1000

  def init_ do
    [] |> List.duplicate(@bucket_size) |> List.to_tuple()
  end

  def put(hash_map, key, value) do
    hash_key = hash(key)
    bucket = elem(hash_map, hash_key)
    new_bucket = do_put(bucket, key, value)

    put_elem(hash_map, hash_key, new_bucket)
  end

  # nothing is in the bucket, insert the key/value tuple
  defp do_put([], key, value) do
    [{key, value}]
  end

  # a matching entry was found, replace the value
  defp do_put([{key, _} | rest], key, value) do
    [{key, value} | rest]
  end

  # continue searching for a matching entry
  defp do_put([head | rest], key, value) do
    [head | do_put(rest, key, value)]
  end

  def get(hash_map, key) do
    hash_key = hash(key)
    bucket = elem(hash_map, hash_key)

    do_get(bucket, key)
  end

  # the list is empty, return -1 by default
  defp do_get([], _key) do
    -1
  end

  defp do_get([{key, value} | _rest], key) do
    value
  end

  defp do_get([_head | rest], key) do
    do_get(rest, key)
  end

  def remove(hash_map, key) do
    hash_key = hash(key)
    bucket = elem(hash_map, hash_key)
    new_bucket = Enum.filter(bucket, fn {k, _v} -> k != key end)

    put_elem(hash_map, hash_key, new_bucket)
  end

  defp hash(key) do
    rem(key, @bucket_size)
  end
end

# Example Usage
my_hash_map = MyHashMap.init_()

my_hash_map = MyHashMap.put(my_hash_map, 1, 10)
my_hash_map = MyHashMap.put(my_hash_map, 1022, 20)
my_hash_map = MyHashMap.put(my_hash_map, 2, 200)

IO.puts("Value for key 1: #{MyHashMap.get(my_hash_map, 1)}")
IO.puts("Value for key 1022: #{MyHashMap.get(my_hash_map, 1022)}")
IO.puts("Value for key 2: #{MyHashMap.get(my_hash_map, 2)}")
IO.puts("Value for key 99: #{MyHashMap.get(my_hash_map, 99)}")

my_hash_map = MyHashMap.remove(my_hash_map, 1)
IO.puts("Value for key 1 after removal: #{MyHashMap.get(my_hash_map, 1)}")
```

### 242. Valid Anagram

Given two strings s and t, return true if t is an of s, and false otherwise.

Example 1:

Input: s = "anagram", t = "nagaram"
Output: true

Example 2:
Input: s = "rat", t = "car"
Output: false

Constraints:

```
1 <= s.length, t.length <= 5 * 104
s and t consist of lowercase English letters.
```

Follow up: What if the inputs contain Unicode characters? How would you adapt your solution to such a case?

```elixir
s = "anagram"
t = "nagaram"

# s = "ab"
# t = "a"

s |> String.graphemes() |> Enum.frequencies() == t |> String.graphemes() |> Enum.frequencies()
```

### 125. Valid Palindrome

A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.

Given a string s, return true if it is a palindrome, or false otherwise.

Example 1:

Input: s = "A man, a plan, a canal: Panama"
Output: true
Explanation: "amanaplanacanalpanama" is a palindrome.

Example 2:

Input: s = "race a car"
Output: false
Explanation: "raceacar" is not a palindrome.

Example 3:

Input: s = " "
Output: true
Explanation: s is an empty string "" after removing non-alphanumeric characters.
Since an empty string reads the same forward and backward, it is a palindrome.

Constraints:

```
1 <= s.length <= 2 * 105
s consists only of printable ASCII characters.
```

```elixir
s = "A man, a plan, a canal: Panama"
s = "ab_a"
filtered = s |> String.downcase() |> String.replace(~r/[^a-zA-Z0-9]/, "") |> String.graphemes()
Enum.reverse(filtered) == filtered
```

### 704. Binary Search

Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1.

You must write an algorithm with O(log n) runtime complexity.

Example 1:

Input: nums = [-1,0,3,5,9,12], target = 9
Output: 4
Explanation: 9 exists in nums and its index is 4

Example 2:

Input: nums = [-1,0,3,5,9,12], target = 2
Output: -1
Explanation: 2 does not exist in nums so return -1

Constraints:

```
1 <= nums.length <= 104
-104 < nums[i], target < 104
All the integers in nums are unique.
nums is sorted in ascending order.
```

```elixir
defmodule BinarySearch do
  @spec search(nums :: [integer], target :: integer) :: integer
  def search(nums, target) when is_list(nums) do
    do_search(nums, target, 0, length(nums) - 1)
  end

  defp do_search(_list, _target, low, high) when low > high, do: -1

  defp do_search(list, target, low, high) do
    mid = low + div(high - low, 2)
    case Enum.at(list, mid) do
      nil -> -1  # This case handles an empty list gracefully
      element when element == target -> mid
      element when element < target -> do_search(list, target, mid + 1, high)
      _element -> do_search(list, target, low, mid - 1)
    end
  end
end

nums = [-1,0,3,5,9,12]
target = 9

BinarySearch.search(nums, target)
```

```elixir
defmodule BFS do
  @doc """
  Performs a Breadth-First Search on a graph, starting from a given node.
  Returns a list of nodes in the order they were visited.
  """
  def traverse(graph, start_node) do
    # The queue will be a list of nodes to visit.
    # The visited set will be a MapSet to ensure O(1) lookups.
    queue = [start_node]
    visited = MapSet.new([start_node])
    do_traverse(graph, queue, visited, [])
  end

  defp do_traverse(_graph, [], _visited, result), do: Enum.reverse(result)

  defp do_traverse(graph, [current_node | rest_of_queue], visited, result) do
    # Add the current node to the result list
    result = [current_node | result]

    # Get the neighbors of the current node
    neighbors = Map.get(graph, current_node, [])

    # Filter out neighbors that have already been visited
    new_neighbors = neighbors
    |> Enum.filter(fn neighbor -> not MapSet.member?(visited, neighbor) end)

    # Add new neighbors to the end of the queue
    new_queue = rest_of_queue ++ new_neighbors

    # Add new neighbors to the visited set
    new_visited = Enum.reduce(new_neighbors, visited, fn neighbor, acc ->
      MapSet.put(acc, neighbor)
    end)

    # Recurse with the updated queue, visited set, and result
    do_traverse(graph, new_queue, new_visited, result)
  end
end
```

```elixir
defmodule DFS do
  @doc """
  Performs a Depth-First Search on a graph, starting from a given node.
  Returns a list of nodes in the order they were visited.
  """
  def traverse(graph, start_node) do
    # The stack will be a list of nodes to visit.
    # The visited set will be a MapSet to ensure O(1) lookups.
    stack = [start_node]
    visited = MapSet.new([start_node])
    do_traverse(graph, stack, visited, [])
  end

  defp do_traverse(_graph, [], _visited, result), do: Enum.reverse(result)

  defp do_traverse(graph, [current_node | rest_of_stack], visited, result) do
    # Add the current node to the result list
    result = [current_node | result]

    # Get the neighbors of the current node
    neighbors = Map.get(graph, current_node, [])

    # Filter out neighbors that have already been visited
    new_neighbors = neighbors
    |> Enum.filter(fn neighbor -> not MapSet.member?(visited, neighbor) end)

    # Push new neighbors onto the stack (prepending to the list)
    new_stack = new_neighbors ++ rest_of_stack

    # Add new neighbors to the visited set
    new_visited = Enum.reduce(new_neighbors, visited, fn neighbor, acc ->
      MapSet.put(acc, neighbor)
    end)

    # Recurse with the updated stack, visited set, and result
    do_traverse(graph, new_stack, new_visited, result)
  end
end
```

### 70. Climbing Stairs

You are climbing a staircase. It takes n steps to reach the top.

Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?

Example 1:

Input: n = 2
Output: 2
Explanation: There are two ways to climb to the top.

1. 1 step + 1 step
2. 2 steps

Example 2:

Input: n = 3
Output: 3
Explanation: There are three ways to climb to the top.

1. 1 step + 1 step + 1 step
2. 1 step + 2 steps
3. 2 steps + 1 step

Constraints:

```
1 <= n <= 45
```

```elixir
n = 3

# can take either 1 or 2 steps

defmodule Fibonacci do
  def climb_stairs(n) do
    do_fib(n, 1, 1)
  end

  defp do_fib(0, result, _next), do: result

  defp do_fib(n, result, next) do
    do_fib(n - 1, next, result + next)
  end
end

Fibonacci.climb_stairs(n)

Enum.reduce(0..n - 1, {1, 1}, fn _i, {one, two} ->
  temp = one
  one = one + two
  two = temp
  {one, two}
end)
|> elem(1)
```

### 146. LRU Cache

Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.

Implement the LRUCache class:

```
LRUCache(int capacity) Initialize the LRU cache with positive size capacity.
int get(int key) Return the value of the key if the key exists, otherwise return -1.
void put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key.
```

The functions get and put must each run in O(1) average time complexity.

Example 1:

Input
["LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get"]
[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]
Output
[null, null, null, 1, null, -1, null, -1, 3, 4]

Explanation
LRUCache lRUCache = new LRUCache(2);
lRUCache.put(1, 1); // cache is {1=1}
lRUCache.put(2, 2); // cache is {1=1, 2=2}
lRUCache.get(1);    // return 1
lRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}
lRUCache.get(2);    // returns -1 (not found)
lRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}
lRUCache.get(1);    // return -1 (not found)
lRUCache.get(3);    // return 3
lRUCache.get(4);    // return 4

```elixir
# map/queue implementation
defmodule LRUCache do
  def init_(capacity) do
    %{capacity: capacity, cache: %{}, lru_order: :queue.new()}
  end

  def get(state, key) do
    case Map.get(state.cache, key) do
      nil ->
        IO.puts("-1")
        state

      value ->
        IO.inspect(value)
        %{state | lru_order: update_queue_order(state.lru_order, key)}
    end
  end

  def put(state, key, value) do
    case Map.get(state.cache, key) do
      nil ->
        if :queue.len(state.lru_order) >= state.capacity do
          {{:value, item}, new_queue} = :queue.out(state.lru_order)
          cache = Map.delete(state.cache, item)
          cache = Map.put(cache, key, value)
          new_lru_order = :queue.in(key, new_queue)
          
          %{state | cache: cache, lru_order: new_lru_order}
        else
          cache = Map.put(state.cache, key, value)
          new_lru_order = :queue.in(key, state.lru_order)
          %{state | cache: cache, lru_order: new_lru_order}
        end
          
      value ->
        %{state | lru_order: update_queue_order(state.lru_order, key), cache: Map.put(state.cache, key, value)}
    end
  end

  defp update_queue_order(lru_order, key) do
    new_queue = :queue.delete(key, lru_order)
    :queue.in(key, new_queue)
  end
end

state = LRUCache.init_(2)
state = LRUCache.put(state, 1, 1); # cache is {1=1}
state = LRUCache.put(state, 2, 2); # cache is {1=1, 2=2}
state = LRUCache.get(state, 1);    # return 1
state = LRUCache.put(state, 3, 3); # LRU key was 2, evicts key 2, cache is {1=1, 3=3}
state = LRUCache.get(state, 2);    # returns -1 (not found)
state = LRUCache.put(state, 4, 4); # LRU key was 1, evicts key 1, cache is {4=4, 3=3}
state = LRUCache.get(state, 1);    # return -1 (not found)
state = LRUCache.get(state, 3);    # return 3
state = LRUCache.get(state, 4);    # return 4
```

```elixir
# GenServer map implementation
defmodule LRUCache1 do
  def init_(capacity) do
    LRUCacheMap1.start_link(capacity: capacity)
  end

  def get(key) do
    LRUCacheMap1.get(key)
  end

  def put(key, value) do
    LRUCacheMap1.put(key, value)
  end
end

defmodule LRUCacheMap1 do
  use GenServer

  def start_link(opts) do
    GenServer.start_link(__MODULE__, opts, name: __MODULE__)
  end

  @impl true
  def init(opts) do
    capacity = Keyword.get(opts, :capacity, opts)
    
    {:ok, %{cache: %{}, lru_order: :queue.new(), capacity: capacity}}
  end

  def get(key) do
    GenServer.call(__MODULE__, {:get, key})
  end

  def put(key, value) do
    GenServer.cast(__MODULE__, {:put, key, value})
  end

  @impl true
  def handle_call({:get, key}, _from, state) do
    case Map.get(state.cache, key) do
      nil ->
        {:reply, -1, state}
        
      value ->
        new_state = %{state | lru_order: update_queue_order(state.lru_order, key)}
        
        {:reply, value, new_state}
    end
  end

  @impl true
  def handle_cast({:put, key, value}, state) do
    case Map.get(state.cache, key) do
      nil ->
        if :queue.len(state.lru_order) >= state.capacity do
          {{:value, item}, new_queue} = :queue.out(state.lru_order)
          cache = Map.delete(state.cache, item)
          cache = Map.put(cache, key, value)
          new_lru_order = :queue.in(key, new_queue)
          
          {:noreply, %{state | cache: cache, lru_order: new_lru_order}}
        else
          cache = Map.put(state.cache, key, value)
          new_lru_order = :queue.in(key, state.lru_order)
          {:noreply, %{state | cache: cache, lru_order: new_lru_order}}
        end
          
      value ->
        {:noreply, %{state | cache: Map.put(state.cache, key, value), lru_order: update_queue_order(state.lru_order, key)}}
    end
  end

  defp update_queue_order(lru_order, key) do
    new_queue = :queue.delete(key, lru_order)
    :queue.in(key, new_queue)
  end
end

# {:error, {:already_started, pid}} = LRUCache1.init_(2)
# Process.exit(pid, :kill)
# LRUCache1.put(1, 1); # cache is {1=1}
# LRUCache1.put(2, 2); # cache is {1=1, 2=2}
# LRUCache1.get(1);    # return 1
# LRUCache1.put(3, 3); # LRU key was 2, evicts key 2, cache is {1=1, 3=3}
# LRUCache1.get(2);    # returns -1 (not found)
# LRUCache1.put(4, 4); # LRU key was 1, evicts key 1, cache is {4=4, 3=3}
# LRUCache1.get(1);    # return -1 (not found)
# LRUCache1.get(3);    # return 3
# LRUCache1.get(4);    # return 4
```

```elixir
# GenServer ets implementation
defmodule LRUCache2 do
  def init_(capacity) do
    LRUCacheMap2.start_link(capacity: capacity)
  end

  def get(key) do
    LRUCacheMap2.get(key)
  end

  def put(key, value) do
    LRUCacheMap2.put(key, value)
  end
end

defmodule LRUCacheMap2 do
  use GenServer

  @table :cache

  def start_link(opts) do
    GenServer.start_link(__MODULE__, opts, name: __MODULE__)
  end

  @impl true
  def init(opts) do
    capacity = Keyword.get(opts, :capacity, opts)
    
    {:ok, %{cache: :ets.new(@table, [:set, :named_table, :public]), lru_order: :queue.new(), capacity: capacity}}
  end

  def get(key) do
    case :ets.lookup(@table, key) do
      [{^key, value}] -> value
      [] -> -1
    end
  end

  def put(key, value) do
    GenServer.cast(__MODULE__, {:put, key, value})
  end

  @impl true
  def handle_cast({:put, key, value}, state) do
    case get(key) do
      -1 ->
        if :queue.len(state.lru_order) >= state.capacity do
          {{:value, item}, new_queue} = :queue.out(state.lru_order)
          :ets.delete(@table, item)
          :ets.insert(@table, {key, value})
          new_lru_order = :queue.in(key, new_queue)
          
          {:noreply, %{state | lru_order: new_lru_order}}
        else
          :ets.insert(@table, {key, value})
          new_lru_order = :queue.in(key, state.lru_order)
          {:noreply, %{state | lru_order: new_lru_order}}
        end
          
      value ->
        :ets.insert(@table, {key, value})
        {:noreply, %{state | lru_order: update_queue_order(state.lru_order, key)}}
    end
  end

  defp update_queue_order(lru_order, key) do
    new_queue = :queue.delete(key, lru_order)
    :queue.in(key, new_queue)
  end
end

# {:error, {:already_started, pid}} = LRUCache2.init_(2)
# Process.exit(pid, :kill)
# LRUCache2.init_(2)
# LRUCache2.put(1, 1); # cache is {1=1}
# LRUCache2.put(2, 2); # cache is {1=1, 2=2}
# LRUCache2.get(1);    # return 1
# LRUCache2.put(3, 3); # LRU key was 2, evicts key 2, cache is {1=1, 3=3}
# LRUCache2.get(2);    # returns -1 (not found)
# LRUCache2.put(4, 4); # LRU key was 1, evicts key 1, cache is {4=4, 3=3}
# LRUCache2.get(1);    # return -1 (not found)
# LRUCache2.get(3);    # return 3
# LRUCache2.get(4);    # return 4
```

### 1046. Last Stone Weight

You are given an array of integers stones where stones[i] is the weight of the ith stone.

We are playing a game with the stones. On each turn, we choose the heaviest two stones and smash them together. Suppose the heaviest two stones have weights x and y with x <= y. The result of this smash is:

```
If x == y, both stones are destroyed, and
If x != y, the stone of weight x is destroyed, and the stone of weight y has new weight y - x.
```

At the end of the game, there is at most one stone left.

Return the weight of the last remaining stone. If there are no stones left, return 0.

Example 1:

Input: stones = [2,7,4,1,8,1]
Output: 1
Explanation: 
We combine 7 and 8 to get 1 so the array converts to [2,4,1,1,1] then,
we combine 2 and 4 to get 2 so the array converts to [2,1,1,1] then,
we combine 2 and 1 to get 1 so the array converts to [1,1,1] then,
we combine 1 and 1 to get 0 so the array converts to [1] then that's the value of the last stone.

Example 2:

Input: stones = [1]
Output: 1

Constraints:

```
1 <= stones.length <= 30
1 <= stones[i] <= 1000
```

```elixir
stones = [2,7,4,1,8,1]

defmodule LSW do
  def last_stone_weight([]), do: 0
  def last_stone_weight([stone]), do: stone
  def last_stone_weight(stones) do
    stones |> smash() |> last_stone_weight()
  end

  defp smash(stones) do
    [first, second | rest] = Enum.sort(stones, :desc)
    [first - second | rest]
  end
end

LSW.last_stone_weight(stones)
```

### 226. Invert Binary Tree

```elixir
defmodule TreeNode do
  defstruct val: 0, left: nil, right: nil
end

defmodule IBT do
  def invert_tree(nil), do: nil
  def invert_tree(root = %{left: left, right: right}) do
    %{root | left: invert_tree(right), right: invert_tree(left)}
  end
end
```

### 104. Maximum Depth of a Binary Tree

```elixir
defmodule TreeNode do
  defstruct val: 0, left: nil, right: nil
end

defmodule MD do
  def max_depth(nil): do, 0
  def max_depth(root) do
    1 + max(max_depth(root.left), max_depth(root.right))
  end
end
```

### 543. Diameter of a Binary Tree

```elixir
defmodule DBT do
  def diameter_of_binary_tree(root) do
    {_height, max} = do_diameter(root)
    max
  end

  defp do_diameter(nil), do: {0, 0}
  
  defp do_diameter(root) do
    {hl, ml} = do_diameter(root.left)
    {hr, mr} = do_diameter(root.right)

    height = 1 + max(hl, hr)
    max = max(hl + hr, max(ml, mr))
    {height, max}
  end
end
```

### 110. Balanced Binary Tree

```elixir
defmodule BBT do
  def is_balanced(root) do
    {balanced?, _} = do_balanced(root)
    balanced?
  end

  defp do_balanced(nil), do: {true, 0}
  
  defp do_balanced(root) do
    {left_balanced?, left_height} = do_balanced(root.left)
    {right_balanced?, right_height} = do_balanced(root.right)
    
    if left_balanced? and right_balanced? and abs(left_height - right_height) <= 1 do
      {true, 1 + max(left_height, right_height)}
    else
      {false, 0}
    end
  end
end
```

## 337. House Robber III

```elixir
defmodule HR3 do
  def rob(root) do
    Enum.max(do_rob(root))
  end

  defp do_rob(nil), do: [0, 0]

  defp do_rob(root) do
    [_left1, left2] = left_pair = do_rob(root.left)
    [_right1, right2] = right_pair = do_rob(root.right)

    with_root = root.val + left2 + right2
    without_root = Enum.max(left_pair) + Enum.max(right_pair)

    [with_root, without_root]
  end
end
```

## 733. Flood Fill

```elixir
defmodule FF do
  def flood_fill(image, sr, sc, color) do
    start_color = get_pixel(image, sr, sc)
    
    if start_color == color do
      image
    else
      dfs(image, sr, sc, start_color, color)
    end
  end
  
  defp dfs(image, r, c, start_color, new_color) do
    rows = length(image)
    cols = length(hd(image))
    
    if r < 0 or r >= rows or c < 0 or c >= cols or 
       get_pixel(image, r, c) != start_color do
      image
    else
      image = set_pixel(image, r, c, new_color)
      
      image
      |> dfs(r + 1, c, start_color, new_color)
      |> dfs(r - 1, c, start_color, new_color)
      |> dfs(r, c + 1, start_color, new_color)
      |> dfs(r, c - 1, start_color, new_color)
    end
  end

  defp get_pixel(image, r, c) do
    image |> Enum.at(r) |> Enum.at(c)
  end
  
  defp set_pixel(image, r, c, color) do
    List.update_at(image, r, fn row ->
      List.replace_at(row, c, color)
    end)
  end
end

image = [[1,1,1],[1,1,0],[1,0,1]]
sr = 1
sc = 1
color = 2

FF.flood_fill(image, sr, sc, color)
```

## 200. Number of Islands

```elixir
defmodule NI do
  def num_islands(grid) when grid == [] or hd(grid) == [], do: 0
  
  def num_islands(grid) do
    rows = length(grid)
    cols = length(hd(grid))
    
    {count, _visited} = 
      Enum.reduce(0..(rows - 1), {0, MapSet.new()}, fn r, {count, visited} ->
        Enum.reduce(0..(cols - 1), {count, visited}, fn c, {count, visited} ->
            if get_island(grid, r, c) == "1" and not MapSet.member?(visited, {r, c}) do
              new_visited = dfs(grid, r, c, visited, rows, cols)
              {count + 1, new_visited}
            else
              {count, visited}
            end
        end)
      end)
    
    count
  end
  
  defp dfs(grid, r, c, visited, rows, cols) do
    cond do
      r < 0 or r >= rows or c < 0 or c >= cols ->
        visited
      
      MapSet.member?(visited, {r, c}) ->
        visited
      
      get_island(grid, r, c) != "1" ->
        visited
      
      true ->
        visited = MapSet.put(visited, {r, c})
        
        visited
        |> then(&dfs(grid, r + 1, c, &1, rows, cols))
        |> then(&dfs(grid, r - 1, c, &1, rows, cols))
        |> then(&dfs(grid, r, c + 1, &1, rows, cols))
        |> then(&dfs(grid, r, c - 1, &1, rows, cols))
    end
  end

  defp get_island(grid, r, c) do
    grid |> Enum.at(r) |> Enum.at(c)
  end
end

grid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
]

NI.num_islands(grid)
```

## 13. Roman to Integer

```elixir
s = "MCMXCIV"

roman_to_int = %{
  "I" => 1,
  "V" => 5,
  "X" => 10,
  "L" => 50,
  "C" => 100,
  "D" => 500,
  "M" => 1_000
}

# large to small => add
# small to large => subtract

s
|> String.graphemes()
|> Enum.with_index()
|> Enum.reduce(0, fn {char, i}, result ->
  next_char = String.at(s, i + 1)
  
  if is_binary(next_char) and Map.get(roman_to_int, char) < Map.get(roman_to_int, next_char) do
    result - Map.get(roman_to_int, char)
  else
    result + Map.get(roman_to_int, char)
  end
end)
```
