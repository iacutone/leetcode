<!-- livebook:{"default_language":"python"} -->

# Leetcode

```elixir
Mix.install([
  {:pythonx, "~> 0.4.2"},
  {:kino_pythonx, "~> 0.1.0"}
])
```

```pyproject.toml
[project]
name = "project"
version = "0.0.0"
requires-python = "==3.13.*"
dependencies = []
```

## Intro

My attempt to get better a algorithms based on [this](https://seanprashad.com/leetcode-patterns/) blogpost.

According to the post, there are 180 identifiable patterns that FAANG use as determination for web application development skills to filter out applicants that either have better things to do with their time or are young and have the time available to invest learning leetcode algorithm patterns.

With practice, one can identify the patterns and ostensibly pass a FAANG interview.

<!-- livebook:{"break_markdown":true} -->

### 217. Contains Duplicate

Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct.

Example 1:

Input: nums = [1,2,3,1]

Output: true

Example 2:

Input: nums = [1,2,3,4]

Output: false

Example 3:

Input: nums = [1,1,1,3,3,4,3,2,4,2]

Output: true

```elixir
Enum.reduce_while([1, 2, 3, 4], MapSet.new(), fn num, acc ->
  if MapSet.member?(acc, num) do
    {:halt, true}
  else
    {:cont, MapSet.put(acc, num)}
  end
end)
|> case do
  true -> true
  _ -> false
end

# 08/05/2025
length([1, 2, 3, 1]) != [1, 2, 3, 1] |> Enum.uniq() |> length()
```

```python
def containsDuplicate(nums):
    hashset = set()

    for n in nums:
      if n in hashset:
        return True
        
      hashset.add(n)
    return False

nums = [1,2,3,1]
containsDuplicate(nums)
# True
```

### 268. Missing Number

Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array.

Example 1:

Input: nums = [3,0,1]

Output: 2

Explanation: n = 3 since there are 3 numbers, so all numbers are in the range [0,3]. 2 is the missing number in the range since it does not appear in nums.

Example 2:

Input: nums = [0,1]

Output: 2

Explanation: n = 2 since there are 2 numbers, so all numbers are in the range [0,2]. 2 is the missing number in the range since it does not appear in nums.

Example 3:

Input: nums = [9,6,4,2,3,5,7,0,1]

Output: 8

Explanation: n = 9 since there are 9 numbers, so all numbers are in the range [0,9]. 8 is the missing number in the range since it does not appear in nums.

Constraints:

n == nums.length

1 <= n <= 104

0 <= nums[i] <= n

All the numbers of nums are unique.

Follow up: Could you implement a solution using only O(1) extra space complexity and O(n) runtime complexity?

```elixir
# (n * (n + 1)/2)

nums = [0]
size = length(nums)
sum = Enum.sum(nums)

size
|> :erlang.+(1)
|> :erlang./(2)
|> :erlang.*(size)
|> :erlang.-(sum)
|> round()

# 08/05/2020
n = length([9, 6, 4, 2, 3, 5, 7, 0, 1])
set = MapSet.new([9, 6, 4, 2, 3, 5, 7, 0, 1])

Enum.find(0..n, fn num ->
  !MapSet.member?(set, num)
end)
```

## 448. Find All Numbers Disappeared in an Array

```elixir
nums = [1, 1]
present = MapSet.new(nums)

Enum.filter(1..length(nums), fn i -> not MapSet.member?(present, i) end)
```

```python
def findDisappearedNumbers(nums):
  # for n in nums:
  #   i = abs(n) - 1
  #   nums[i] = -1 * abs(nums[i])
  # res = []
  # for i, n in enumerate(nums):
  #   if n > 0:
  #     res.append(i + 1)
  # return res
    
  return [i for i in range(1, len(nums) + 1) if i not in set(nums)]

nums = [4, 3, 2, 7, 8, 2, 3, 1]
findDisappearedNumbers(nums)
# [5,6]
```

### 121. Best Time to Buy and Sell Stock

You are given an array prices where prices[i] is the price of a given stock on the ith day.

You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.

Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.

Example 1:

Input: prices = [7,1,5,3,6,4]
Output: 5
Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.
Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.
Example 2:

Input: prices = [7,6,4,3,1]
Output: 0
Explanation: In this case, no transactions are done and the max profit = 0.

Constraints:

1 <= prices.length <= 105
0 <= prices[i] <= 104

```elixir
# as a map
prices = [7, 1, 5, 3, 6, 4]
price_map = %{min_price: List.first(prices), max_profit: 0}

result =
  Enum.reduce(prices, price_map, fn price,
                                    %{min_price: min_price, max_profit: max_profit} = acc ->
    acc = Map.put(acc, :min_price, min(price, min_price))
    Map.put(acc, :max_profit, max(max_profit, price - Map.get(acc, :min_price)))
  end)

Map.get(result, :max_profit)

# as a tuple
if length(prices) < 2 do
  0
else
  initial_state = {hd(prices), 0}

  {_min_price, max_profit} =
    Enum.reduce(tl(prices), initial_state, fn price, {min_price, max_profit} ->
      new_min_price = min(min_price, price)
      current_profit = price - new_min_price
      new_max_profit = max(max_profit, current_profit)
      {new_min_price, new_max_profit}
    end)

  max_profit
end
```

### 206. Reverse Linked List

Given the head of a singly linked list, reverse the list, and return the reversed list.

Example 1:

Input: head = [1,2,3,4,5]
Output: [5,4,3,2,1]
Example 2:

Input: head = [1,2]
Output: [2,1]
Example 3:

Input: head = []
Output: []

Constraints:

The number of nodes in the list is the range [0, 5000].
-5000 <= Node.val <= 5000

Follow up: A linked list can be reversed either iteratively or recursively. Could you implement both?

```elixir
defmodule ListNode do
  defstruct val: 0, next: nil
end

defmodule Solution do
  def reverse_list(nil), do: nil

  def reverse_list(list) do
    do_reverse_list(nil, list)
  end

  defp do_reverse_list(previous, nil), do: previous

  defp do_reverse_list(previous, current) do
    next_node = current.next
    new_current = %ListNode{val: current.val, next: previous}
    do_reverse_list(new_current, next_node)
  end
end
```

### 21. Merge Two Sorted Lists

You are given the heads of two sorted linked lists list1 and list2.

Merge the two lists into one sorted list. The list should be made by splicing together the nodes of the first two lists.

Return the head of the merged linked list.

Example 1:

Input: list1 = [1,2,4], list2 = [1,3,4]
Output: [1,1,2,3,4,4]
Example 2:

Input: list1 = [], list2 = []
Output: []
Example 3:

Input: list1 = [], list2 = [0]
Output: [0]

Constraints:

The number of nodes in both lists is in the range [0, 50].
-100 <= Node.val <= 100
Both list1 and list2 are sorted in non-decreasing order.

```elixir
defmodule ListNode do
  defstruct val: 0, next: nil
end

defmodule Solution do
  def merge_two_lists(list1, nil), do: list1
  def merge_two_lists(nil, list2), do: list2

  def merge_two_lists(list1, list2) do
    if list1.val <= list2.val do
      %ListNode{list1 | next: merge_two_lists(list1.next, list2)}
    else
      %ListNode{list2 | next: merge_two_lists(list1, list2.next)}
    end
  end
end
```

### 1. Two Sum

Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.

You may assume that each input would have exactly one solution, and you may not use the same element twice.

You can return the answer in any order.

Example 1:

Input: nums = [2,7,11,15], target = 9
Output: [0,1]
Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].
Example 2:

Input: nums = [3,2,4], target = 6
Output: [1,2]
Example 3:

Input: nums = [3,3], target = 6
Output: [0,1]

Constraints:

2 <= nums.length <= 104
-109 <= nums[i] <= 109
-109 <= target <= 109
Only one valid answer exists.

Follow-up: Can you come up with an algorithm that is less than O(n2) time complexity?

```elixir
nums = [2, 7, 11, 15]
target = 9

Enum.reduce_while(0..(length(nums) - 1), %{}, fn i, acc ->
  current_num = Enum.at(nums, i)
  complement = target - current_num

  if Map.has_key?(acc, complement) do
    {:halt, [Map.get(acc, complement), i]}
  else
    {:cont, Map.put(acc, current_num, i)}
  end
end)
```

```python
def twoSum(nums, target):
    prevMap = {}  # val: index
    
    for i, n in enumerate(nums):
        diff = target - n
        if diff in prevMap:
            return [prevMap[diff], i]
        prevMap[n] = i

nums = [2, 7, 11, 15]
target = 9

twoSum(nums, target)
# [0, 1]
```

### 283. Move Zeroes

Given an integer array nums, move all 0's to the end of it while maintaining the relative order of the non-zero elements.

Note that you must do this in-place without making a copy of the array.

Example 1:

Input: nums = [0,1,0,3,12]
Output: [1,3,12,0,0]
Example 2:

Input: nums = [0]
Output: [0]

Constraints:

1 <= nums.length <= 104
-231 <= nums[i] <= 231 - 1

Follow up: Could you minimize the total number of operations done?

```elixir
nums = [0, 1, 0, 3, 12]

{non_zeros, zeros} = Enum.split_with(nums, fn x -> x != 0 end)
non_zeros ++ zeros
```

```python
nums = [0,1,0,3,12]
l = 0
for r in range(len(nums)):
  if nums[r]:
    nums[l], nums[r] = nums[r], nums[l]
    l += 1
nums
  
# [1,3,12,0,0]
```

### 20. Valid Parentheses

Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.

An input string is valid if:

Open brackets must be closed by the same type of brackets.
Open brackets must be closed in the correct order.
Every close bracket has a corresponding open bracket of the same type.

Example 1:

Input: s = "()"

Output: true

Example 2:

Input: s = "()[]{}"

Output: true

Example 3:

Input: s = "(]"

Output: false

Example 4:

Input: s = "([])"

Output: true

Example 5:

Input: s = "([)]"

Output: false

Constraints:

1 <= s.length <= 104
s consists of parentheses only '()[]{}'.

```elixir
s = "([])"

close_to_open_map = %{
  ")" => "(",
  "]" => "[",
  "}" => "{"
}

s
|> String.graphemes()
|> Enum.reduce([], fn char, stack ->
  case Map.get(close_to_open_map, char) do
    # char is an opening bracket
    nil ->
      [char | stack]

    open_bracket when stack != [] and hd(stack) == open_bracket ->
      # pop from the stack
      tl(stack)

    _ ->
      [:invalid | stack]
  end
end)
|> Enum.empty?()
```

### 238. Product of Array Except Self

Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].

The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.

You must write an algorithm that runs in O(n) time and without using the division operation.

Example 1:

Input: nums = [1,2,3,4]
Output: [24,12,8,6]
Example 2:

Input: nums = [-1,1,0,-3,3]
Output: [0,0,9,0,0]

Constraints:

2 <= nums.length <= 105
-30 <= nums[i] <= 30
The input is generated such that answer[i] is guaranteed to fit in a 32-bit integer.

Follow up: Can you solve the problem in O(1) extra space complexity? (The output array does not count as extra space for space complexity analysis.)

```elixir
# This solution times out on Leetcode
# Would need to implement with hard to grok
# prefix/postfix solution to pass Leetcode

nums = [1, 2, 3, 4]
# nums = [0, 0]

indexed_nums =
  nums
  |> Enum.with_index()
  |> Enum.into(%{}, fn {value, index} -> {index, value} end)

Enum.reduce(0..(length(nums) - 1), [], fn i, acc ->
  output =
    indexed_nums |> Map.delete(i) |> Map.values() |> Enum.reduce(1, fn n, acc -> n * acc end)

  [output | acc]
end)
|> Enum.reverse()
```

### 1047. Remove All Adjacent Duplicates In String

You are given a string s consisting of lowercase English letters. A duplicate removal consists of choosing two adjacent and equal letters and removing them.

We repeatedly make duplicate removals on s until we no longer can.

Return the final string after all such duplicate removals have been made. It can be proven that the answer is unique.

Example 1:

Input: s = "abbaca"
Output: "ca"
Explanation: 
For example, in "abbaca" we could remove "bb" since the letters are adjacent and equal, and this is the only possible move.  The result of this move is that the string is "aaca", of which only "aa" is possible, so the final string is "ca".
Example 2:

Input: s = "azxxzy"
Output: "ay"

Constraints:

1 <= s.length <= 105
s consists of lowercase English letters.

```elixir
s = "abbaca"

s
|> String.graphemes()
|> Enum.reduce([], fn char, stack ->
  case stack do
    [head | _] when head == char ->
      tl(stack)

    _ ->
      [char | stack]
  end
end)
|> Enum.reverse()
|> List.to_string()
```

### 14. Longest Common Prefix

Write a function to find the longest common prefix string amongst an array of strings.

If there is no common prefix, return an empty string "".

Example 1:

Input: strs = ["flower","flow","flight"]
Output: "fl"
Example 2:

Input: strs = ["dog","racecar","car"]
Output: ""
Explanation: There is no common prefix among the input strings.

Constraints:

1 <= strs.length <= 200
0 <= strs[i].length <= 200
strs[i] consists of only lowercase English letters if it is non-empty.

```elixir
strs = ["flower", "flow", "flight"]

defmodule LongestCommonPrefix do
  # recursive approach
  # def longest_common_prefix([]), do: ""
  # def longest_common_prefix([prefix | rest]) do
  #   Enum.reduce(rest, prefix, fn str, acc ->
  #     trim_prefix(str, acc)
  #   end)
  # end

  # defp trim_prefix(str, acc) do
  #   if String.starts_with?(str, acc) do
  #     acc
  #   else
  #     # Recursively trim the prefix by removing the last character
  #     trim_prefix(str, String.slice(acc, 0, String.length(acc) - 1))
  #   end
  # end

  # binary pattern matching recursive approach
  def longest_common_prefix([head | tail]) do
    Enum.reduce(tail, head, fn word, acc ->
      common_prefix(word, acc, "")
    end)
  end

  defp common_prefix(<<c, word_rest::binary>>, <<c, tail_rest::binary>>, common) do
    common_prefix(word_rest, tail_rest, common <> <<c>>)
  end

  defp common_prefix(_, _, common), do: common
end

LongestCommonPrefix.longest_common_prefix(strs)
```

### 706. Design HashMap

Design a HashMap without using any built-in hash table libraries.

Implement the MyHashMap class:

MyHashMap() initializes the object with an empty map.
void put(int key, int value) inserts a (key, value) pair into the HashMap. If the key already exists in the map, update the corresponding value.
int get(int key) returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key.
void remove(key) removes the key and its corresponding value if the map contains the mapping for the key.

Example 1:

Input
["MyHashMap", "put", "put", "get", "get", "put", "get", "remove", "get"]
[[], [1, 1], [2, 2], [1], [3], [2, 1], [2], [2], [2]]
Output
[null, null, null, 1, -1, null, 1, null, -1]

Explanation
MyHashMap myHashMap = new MyHashMap();
myHashMap.put(1, 1); // The map is now [[1,1]]
myHashMap.put(2, 2); // The map is now [[1,1], [2,2]]
myHashMap.get(1);    // return 1, The map is now [[1,1], [2,2]]
myHashMap.get(3);    // return -1 (i.e., not found), The map is now [[1,1], [2,2]]
myHashMap.put(2, 1); // The map is now [[1,1], [2,1]] (i.e., update the existing value)
myHashMap.get(2);    // return 1, The map is now [[1,1], [2,1]]
myHashMap.remove(2); // remove the mapping for 2, The map is now [[1,1]]
myHashMap.get(2);    // return -1 (i.e., not found), The map is now [[1,1]]

```elixir
defmodule MyHashMap do
  @bucket_size 1000

  def init_ do
    [] |> List.duplicate(@bucket_size) |> List.to_tuple()
  end

  def put(hash_map, key, value) do
    hash_key = hash(key)
    bucket = elem(hash_map, hash_key)
    new_bucket = do_put(bucket, key, value)

    put_elem(hash_map, hash_key, new_bucket)
  end

  # nothing is in the bucket, insert the key/value tuple
  defp do_put([], key, value) do
    [{key, value}]
  end

  # a matching entry was found, replace the value
  defp do_put([{key, _} | rest], key, value) do
    [{key, value} | rest]
  end

  # continue searching for a matching entry
  defp do_put([head | rest], key, value) do
    [head | do_put(rest, key, value)]
  end

  def get(hash_map, key) do
    hash_key = hash(key)
    bucket = elem(hash_map, hash_key)

    do_get(bucket, key)
  end

  # the list is empty, return -1 by default
  defp do_get([], _key) do
    -1
  end

  defp do_get([{key, value} | _rest], key) do
    value
  end

  defp do_get([_head | rest], key) do
    do_get(rest, key)
  end

  def remove(hash_map, key) do
    hash_key = hash(key)
    bucket = elem(hash_map, hash_key)
    new_bucket = Enum.filter(bucket, fn {k, _v} -> k != key end)

    put_elem(hash_map, hash_key, new_bucket)
  end

  defp hash(key) do
    rem(key, @bucket_size)
  end
end

# Example Usage
my_hash_map = MyHashMap.init_()

my_hash_map = MyHashMap.put(my_hash_map, 1, 10)
my_hash_map = MyHashMap.put(my_hash_map, 1022, 20)
my_hash_map = MyHashMap.put(my_hash_map, 2, 200)

IO.puts("Value for key 1: #{MyHashMap.get(my_hash_map, 1)}")
IO.puts("Value for key 1022: #{MyHashMap.get(my_hash_map, 1022)}")
IO.puts("Value for key 2: #{MyHashMap.get(my_hash_map, 2)}")
IO.puts("Value for key 99: #{MyHashMap.get(my_hash_map, 99)}")

my_hash_map = MyHashMap.remove(my_hash_map, 1)
IO.puts("Value for key 1 after removal: #{MyHashMap.get(my_hash_map, 1)}")
```

### 242. Valid Anagram

Given two strings s and t, return true if t is an of s, and false otherwise.

Example 1:

Input: s = "anagram", t = "nagaram"
Output: true

Example 2:
Input: s = "rat", t = "car"
Output: false

Constraints:

```
1 <= s.length, t.length <= 5 * 104
s and t consist of lowercase English letters.
```

Follow up: What if the inputs contain Unicode characters? How would you adapt your solution to such a case?

```elixir
s = "anagram"
t = "nagaram"

# s = "ab"
# t = "a"

s |> String.graphemes() |> Enum.frequencies() == t |> String.graphemes() |> Enum.frequencies()
```

### 125. Valid Palindrome

A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.

Given a string s, return true if it is a palindrome, or false otherwise.

Example 1:

Input: s = "A man, a plan, a canal: Panama"
Output: true
Explanation: "amanaplanacanalpanama" is a palindrome.

Example 2:

Input: s = "race a car"
Output: false
Explanation: "raceacar" is not a palindrome.

Example 3:

Input: s = " "
Output: true
Explanation: s is an empty string "" after removing non-alphanumeric characters.
Since an empty string reads the same forward and backward, it is a palindrome.

Constraints:

```
1 <= s.length <= 2 * 105
s consists only of printable ASCII characters.
```

```elixir
s = "A man, a plan, a canal: Panama"
s = "ab_a"
filtered = s |> String.downcase() |> String.replace(~r/[^a-zA-Z0-9]/, "") |> String.graphemes()
Enum.reverse(filtered) == filtered
```

### 704. Binary Search

Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1.

You must write an algorithm with O(log n) runtime complexity.

Example 1:

Input: nums = [-1,0,3,5,9,12], target = 9
Output: 4
Explanation: 9 exists in nums and its index is 4

Example 2:

Input: nums = [-1,0,3,5,9,12], target = 2
Output: -1
Explanation: 2 does not exist in nums so return -1

Constraints:

```
1 <= nums.length <= 104
-104 < nums[i], target < 104
All the integers in nums are unique.
nums is sorted in ascending order.
```

```elixir
defmodule BinarySearch do
  @spec search(nums :: [integer], target :: integer) :: integer
  def search(nums, target) when is_list(nums) do
    do_search(nums, target, 0, length(nums) - 1)
  end

  defp do_search(_list, _target, low, high) when low > high, do: -1

  defp do_search(list, target, low, high) do
    mid = low + div(high - low, 2)
    case Enum.at(list, mid) do
      nil -> -1  # This case handles an empty list gracefully
      element when element == target -> mid
      element when element < target -> do_search(list, target, mid + 1, high)
      _element -> do_search(list, target, low, mid - 1)
    end
  end
end

nums = [-1,0,3,5,9,12]
target = 9

BinarySearch.search(nums, target)
```

```elixir
defmodule BFS do
  @doc """
  Performs a Breadth-First Search on a graph, starting from a given node.
  Returns a list of nodes in the order they were visited.
  """
  def traverse(graph, start_node) do
    # The queue will be a list of nodes to visit.
    # The visited set will be a MapSet to ensure O(1) lookups.
    queue = [start_node]
    visited = MapSet.new([start_node])
    do_traverse(graph, queue, visited, [])
  end

  defp do_traverse(_graph, [], _visited, result), do: Enum.reverse(result)

  defp do_traverse(graph, [current_node | rest_of_queue], visited, result) do
    # Add the current node to the result list
    result = [current_node | result]

    # Get the neighbors of the current node
    neighbors = Map.get(graph, current_node, [])

    # Filter out neighbors that have already been visited
    new_neighbors = neighbors
    |> Enum.filter(fn neighbor -> not MapSet.member?(visited, neighbor) end)

    # Add new neighbors to the end of the queue
    new_queue = rest_of_queue ++ new_neighbors

    # Add new neighbors to the visited set
    new_visited = Enum.reduce(new_neighbors, visited, fn neighbor, acc ->
      MapSet.put(acc, neighbor)
    end)

    # Recurse with the updated queue, visited set, and result
    do_traverse(graph, new_queue, new_visited, result)
  end
end
```

### 70. Climbing Stairs

You are climbing a staircase. It takes n steps to reach the top.

Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?

Example 1:

Input: n = 2
Output: 2
Explanation: There are two ways to climb to the top.

1. 1 step + 1 step
2. 2 steps

Example 2:

Input: n = 3
Output: 3
Explanation: There are three ways to climb to the top.

1. 1 step + 1 step + 1 step
2. 1 step + 2 steps
3. 2 steps + 1 step

Constraints:

```
1 <= n <= 45
```

```elixir
n = 3

# can take either 1 or 2 steps

defmodule Fibonacci do
  def climb_stairs(n) do
    do_fib(n, 1, 1)
  end

  defp do_fib(0, result, _next), do: result

  defp do_fib(n, result, next) do
    do_fib(n - 1, next, result + next)
  end
end

Fibonacci.climb_stairs(n)

Enum.reduce(0..n - 1, {1, 1}, fn _i, {one, two} ->
  temp = one
  one = one + two
  two = temp
  {one, two}
end)
|> elem(1)
```

### 146. LRU Cache

Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.

Implement the LRUCache class:

```
LRUCache(int capacity) Initialize the LRU cache with positive size capacity.
int get(int key) Return the value of the key if the key exists, otherwise return -1.
void put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key.
```

The functions get and put must each run in O(1) average time complexity.

Example 1:

Input
["LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get"]
[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]
Output
[null, null, null, 1, null, -1, null, -1, 3, 4]

Explanation
LRUCache lRUCache = new LRUCache(2);
lRUCache.put(1, 1); // cache is {1=1}
lRUCache.put(2, 2); // cache is {1=1, 2=2}
lRUCache.get(1);    // return 1
lRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}
lRUCache.get(2);    // returns -1 (not found)
lRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}
lRUCache.get(1);    // return -1 (not found)
lRUCache.get(3);    // return 3
lRUCache.get(4);    // return 4

```elixir
# map/queue implementation
defmodule LRUCache do
  def init_(capacity) do
    %{capacity: capacity, cache: %{}, lru_order: :queue.new()}
  end

  def get(state, key) do
    case Map.get(state.cache, key) do
      nil ->
        IO.puts("-1")
        state

      value ->
        IO.inspect(value)
        %{state | lru_order: update_queue_order(state.lru_order, key)}
    end
  end

  def put(state, key, value) do
    case Map.get(state.cache, key) do
      nil ->
        if :queue.len(state.lru_order) >= state.capacity do
          {{:value, item}, new_queue} = :queue.out(state.lru_order)
          cache = Map.delete(state.cache, item)
          cache = Map.put(cache, key, value)
          new_lru_order = :queue.in(key, new_queue)
          
          %{state | cache: cache, lru_order: new_lru_order}
        else
          cache = Map.put(state.cache, key, value)
          new_lru_order = :queue.in(key, state.lru_order)
          %{state | cache: cache, lru_order: new_lru_order}
        end
          
      value ->
        %{state | lru_order: update_queue_order(state.lru_order, key), cache: Map.put(state.cache, key, value)}
    end
  end

  defp update_queue_order(lru_order, key) do
    new_queue = :queue.delete(key, lru_order)
    :queue.in(key, new_queue)
  end
end

state = LRUCache.init_(2)
state = LRUCache.put(state, 1, 1); # cache is {1=1}
state = LRUCache.put(state, 2, 2); # cache is {1=1, 2=2}
state = LRUCache.get(state, 1);    # return 1
state = LRUCache.put(state, 3, 3); # LRU key was 2, evicts key 2, cache is {1=1, 3=3}
state = LRUCache.get(state, 2);    # returns -1 (not found)
state = LRUCache.put(state, 4, 4); # LRU key was 1, evicts key 1, cache is {4=4, 3=3}
state = LRUCache.get(state, 1);    # return -1 (not found)
state = LRUCache.get(state, 3);    # return 3
state = LRUCache.get(state, 4);    # return 4
```

```elixir
# GenServer map implementation
defmodule LRUCache1 do
  def init_(capacity) do
    LRUCacheMap1.start_link(capacity: capacity)
  end

  def get(key) do
    LRUCacheMap1.get(key)
  end

  def put(key, value) do
    LRUCacheMap1.put(key, value)
  end
end

defmodule LRUCacheMap1 do
  use GenServer

  def start_link(opts) do
    GenServer.start_link(__MODULE__, opts, name: __MODULE__)
  end

  @impl true
  def init(opts) do
    capacity = Keyword.get(opts, :capacity, opts)
    
    {:ok, %{cache: %{}, lru_order: :queue.new(), capacity: capacity}}
  end

  def get(key) do
    GenServer.call(__MODULE__, {:get, key})
  end

  def put(key, value) do
    GenServer.cast(__MODULE__, {:put, key, value})
  end

  @impl true
  def handle_call({:get, key}, _from, state) do
    case Map.get(state.cache, key) do
      nil ->
        {:reply, -1, state}
        
      value ->
        new_state = %{state | lru_order: update_queue_order(state.lru_order, key)}
        
        {:reply, value, new_state}
    end
  end

  @impl true
  def handle_cast({:put, key, value}, state) do
    case Map.get(state.cache, key) do
      nil ->
        if :queue.len(state.lru_order) >= state.capacity do
          {{:value, item}, new_queue} = :queue.out(state.lru_order)
          cache = Map.delete(state.cache, item)
          cache = Map.put(cache, key, value)
          new_lru_order = :queue.in(key, new_queue)
          
          {:noreply, %{state | cache: cache, lru_order: new_lru_order}}
        else
          cache = Map.put(state.cache, key, value)
          new_lru_order = :queue.in(key, state.lru_order)
          {:noreply, %{state | cache: cache, lru_order: new_lru_order}}
        end
          
      value ->
        {:noreply, %{state | cache: Map.put(state.cache, key, value), lru_order: update_queue_order(state.lru_order, key)}}
    end
  end

  defp update_queue_order(lru_order, key) do
    new_queue = :queue.delete(key, lru_order)
    :queue.in(key, new_queue)
  end
end

# {:error, {:already_started, pid}} = LRUCache1.init_(2)
# Process.exit(pid, :kill)
# LRUCache1.put(1, 1); # cache is {1=1}
# LRUCache1.put(2, 2); # cache is {1=1, 2=2}
# LRUCache1.get(1);    # return 1
# LRUCache1.put(3, 3); # LRU key was 2, evicts key 2, cache is {1=1, 3=3}
# LRUCache1.get(2);    # returns -1 (not found)
# LRUCache1.put(4, 4); # LRU key was 1, evicts key 1, cache is {4=4, 3=3}
# LRUCache1.get(1);    # return -1 (not found)
# LRUCache1.get(3);    # return 3
# LRUCache1.get(4);    # return 4
```

```elixir
# GenServer ets implementation
defmodule LRUCache2 do
  def init_(capacity) do
    LRUCacheMap2.start_link(capacity: capacity)
  end

  def get(key) do
    LRUCacheMap2.get(key)
  end

  def put(key, value) do
    LRUCacheMap2.put(key, value)
  end
end

defmodule LRUCacheMap2 do
  use GenServer

  @table :cache

  def start_link(opts) do
    GenServer.start_link(__MODULE__, opts, name: __MODULE__)
  end

  @impl true
  def init(opts) do
    capacity = Keyword.get(opts, :capacity, opts)
    
    {:ok, %{cache: :ets.new(@table, [:set, :named_table, :public]), lru_order: :queue.new(), capacity: capacity}}
  end

  def get(key) do
    case :ets.lookup(@table, key) do
      [{^key, value}] -> value
      [] -> -1
    end
  end

  def put(key, value) do
    GenServer.cast(__MODULE__, {:put, key, value})
  end

  @impl true
  def handle_cast({:put, key, value}, state) do
    case get(key) do
      -1 ->
        if :queue.len(state.lru_order) >= state.capacity do
          {{:value, item}, new_queue} = :queue.out(state.lru_order)
          :ets.delete(@table, item)
          :ets.insert(@table, {key, value})
          new_lru_order = :queue.in(key, new_queue)
          
          {:noreply, %{state | lru_order: new_lru_order}}
        else
          :ets.insert(@table, {key, value})
          new_lru_order = :queue.in(key, state.lru_order)
          {:noreply, %{state | lru_order: new_lru_order}}
        end
          
      value ->
        :ets.insert(@table, {key, value})
        {:noreply, %{state | lru_order: update_queue_order(state.lru_order, key)}}
    end
  end

  defp update_queue_order(lru_order, key) do
    new_queue = :queue.delete(key, lru_order)
    :queue.in(key, new_queue)
  end
end

# {:error, {:already_started, pid}} = LRUCache2.init_(2)
# Process.exit(pid, :kill)
# LRUCache2.init_(2)
# LRUCache2.put(1, 1); # cache is {1=1}
# LRUCache2.put(2, 2); # cache is {1=1, 2=2}
# LRUCache2.get(1);    # return 1
# LRUCache2.put(3, 3); # LRU key was 2, evicts key 2, cache is {1=1, 3=3}
# LRUCache2.get(2);    # returns -1 (not found)
# LRUCache2.put(4, 4); # LRU key was 1, evicts key 1, cache is {4=4, 3=3}
# LRUCache2.get(1);    # return -1 (not found)
# LRUCache2.get(3);    # return 3
# LRUCache2.get(4);    # return 4
```

### 1046. Last Stone Weight

You are given an array of integers stones where stones[i] is the weight of the ith stone.

We are playing a game with the stones. On each turn, we choose the heaviest two stones and smash them together. Suppose the heaviest two stones have weights x and y with x <= y. The result of this smash is:

```
If x == y, both stones are destroyed, and
If x != y, the stone of weight x is destroyed, and the stone of weight y has new weight y - x.
```

At the end of the game, there is at most one stone left.

Return the weight of the last remaining stone. If there are no stones left, return 0.

Example 1:

Input: stones = [2,7,4,1,8,1]
Output: 1
Explanation: 
We combine 7 and 8 to get 1 so the array converts to [2,4,1,1,1] then,
we combine 2 and 4 to get 2 so the array converts to [2,1,1,1] then,
we combine 2 and 1 to get 1 so the array converts to [1,1,1] then,
we combine 1 and 1 to get 0 so the array converts to [1] then that's the value of the last stone.

Example 2:

Input: stones = [1]
Output: 1

Constraints:

```
1 <= stones.length <= 30
1 <= stones[i] <= 1000
```

```elixir
stones = [2,7,4,1,8,1]

defmodule LSW do
  def last_stone_weight([]), do: 0
  def last_stone_weight([stone]), do: stone
  def last_stone_weight(stones) do
    stones |> smash() |> last_stone_weight()
  end

  defp smash(stones) do
    [first, second | rest] = Enum.sort(stones, :desc)
    [first - second | rest]
  end
end

LSW.last_stone_weight(stones)
```

### 226. Invert Binary Tree

```elixir
defmodule TreeNode do
  defstruct val: 0, left: nil, right: nil
end

defmodule IBT do
  def invert_tree(nil), do: nil
  def invert_tree(root = %{left: left, right: right}) do
    %{root | left: invert_tree(right), right: invert_tree(left)}
  end
end
```

### 104. Maximum Depth of a Binary Tree

```elixir
defmodule MDBT1 do
  def max_depth(nil), do: 0
  def max_depth(root) do
    1 + max(max_depth(root.left), max_depth(root.right))
  end
end
```

### 543. Diameter of a Binary Tree

```elixir
defmodule DBT do
  def diameter_of_binary_tree(root) do
    {_height, max} = do_diameter(root)
    max
  end

  defp do_diameter(nil), do: {0, 0}
  
  defp do_diameter(root) do
    {hl, ml} = do_diameter(root.left)
    {hr, mr} = do_diameter(root.right)

    height = 1 + max(hl, hr)
    max = max(hl + hr, max(ml, mr))
    {height, max}
  end
end
```

### 110. Balanced Binary Tree

```elixir
defmodule BBT do
  def is_balanced(root) do
    {balanced?, _} = do_balanced(root)
    balanced?
  end

  defp do_balanced(nil), do: {true, 0}
  
  defp do_balanced(root) do
    {left_balanced?, left_height} = do_balanced(root.left)
    {right_balanced?, right_height} = do_balanced(root.right)
    
    if left_balanced? and right_balanced? and abs(left_height - right_height) <= 1 do
      {true, 1 + max(left_height, right_height)}
    else
      {false, 0}
    end
  end
end
```

## 733. Flood Fill

```elixir
defmodule FF do
  def flood_fill(image, sr, sc, color) do
    start_color = get_pixel(image, sr, sc)
    
    if start_color == color do
      image
    else
      dfs(image, sr, sc, start_color, color)
    end
  end
  
  defp dfs(image, r, c, start_color, new_color) do
    rows = length(image)
    cols = length(hd(image))
    
    if r < 0 or r >= rows or c < 0 or c >= cols or 
       get_pixel(image, r, c) != start_color do
      image
    else
      image = set_pixel(image, r, c, new_color)
      
      image
      |> dfs(r + 1, c, start_color, new_color)
      |> dfs(r - 1, c, start_color, new_color)
      |> dfs(r, c + 1, start_color, new_color)
      |> dfs(r, c - 1, start_color, new_color)
    end
  end

  defp get_pixel(image, r, c) do
    image |> Enum.at(r) |> Enum.at(c)
  end
  
  defp set_pixel(image, r, c, color) do
    List.update_at(image, r, fn row ->
      List.replace_at(row, c, color)
    end)
  end
end

image = [[1,1,1],[1,1,0],[1,0,1]]
sr = 1
sc = 1
color = 2

FF.flood_fill(image, sr, sc, color)
```

## 337. House Robber III

```elixir
defmodule HR3 do
  def rob(root) do
    Enum.max(do_rob(root))
  end

  defp do_rob(nil), do: [0, 0]

  defp do_rob(root) do
    [_left1, left2] = left_pair = do_rob(root.left)
    [_right1, right2] = right_pair = do_rob(root.right)

    with_root = root.val + left2 + right2
    without_root = Enum.max(left_pair) + Enum.max(right_pair)

    [with_root, without_root]
  end
end
```

## 200. Number of Islands

```elixir
defmodule NI do
  def num_islands(grid) when grid == [] or hd(grid) == [], do: 0
  
  def num_islands(grid) do
    rows = length(grid)
    cols = length(hd(grid))
    
    {count, _visited} = 
      Enum.reduce(0..(rows - 1), {0, MapSet.new()}, fn r, {count, visited} ->
        Enum.reduce(0..(cols - 1), {count, visited}, fn c, {count, visited} ->
            if get_island(grid, r, c) == "1" and not MapSet.member?(visited, {r, c}) do
              new_visited = dfs(grid, r, c, visited, rows, cols)
              {count + 1, new_visited}
            else
              {count, visited}
            end
        end)
      end)
    
    count
  end
  
  defp dfs(grid, r, c, visited, rows, cols) do
    cond do
      r < 0 or r >= rows or c < 0 or c >= cols ->
        visited
      
      MapSet.member?(visited, {r, c}) ->
        visited
      
      get_island(grid, r, c) != "1" ->
        visited
      
      true ->
        visited = MapSet.put(visited, {r, c})
        
        visited
        |> then(&dfs(grid, r + 1, c, &1, rows, cols))
        |> then(&dfs(grid, r - 1, c, &1, rows, cols))
        |> then(&dfs(grid, r, c + 1, &1, rows, cols))
        |> then(&dfs(grid, r, c - 1, &1, rows, cols))
    end
  end

  defp get_island(grid, r, c) do
    grid |> Enum.at(r) |> Enum.at(c)
  end
end

grid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
]

NI.num_islands(grid)
```

## 13. Roman to Integer

```elixir
s = "MCMXCIV"

roman_to_int = %{
  "I" => 1,
  "V" => 5,
  "X" => 10,
  "L" => 50,
  "C" => 100,
  "D" => 500,
  "M" => 1_000
}

# large to small => add
# small to large => subtract

s
|> String.graphemes()
|> Enum.with_index()
|> Enum.reduce(0, fn {char, i}, result ->
  next_char = String.at(s, i + 1)
  
  if is_binary(next_char) and Map.get(roman_to_int, char) < Map.get(roman_to_int, next_char) do
    result - Map.get(roman_to_int, char)
  else
    result + Map.get(roman_to_int, char)
  end
end)
```

## 169. Majority Element

```elixir
nums = [2,2,1,1,1,2,2]

nums 
|> Enum.frequencies()
|> Enum.max_by(fn {_k, v} -> v end)
|> then(fn {k, _v} -> k end)
```

## 136. Single Number

```elixir
nums = [4,1,2,1,2]

nums
|> Enum.frequencies()
|> Enum.min_by(fn {_k, v} -> v end)
|> then(fn {k, _v} -> k end)

Enum.reduce(nums, 0, fn n, acc -> Bitwise.bxor(n, acc) end)
```

```python
def singleNumber(nums):
  res = 0
  for n in nums:
    res = n ^ res
  return res

nums = [4,1,2,1,2]
singleNumber(nums)
```

## 118. Pascal's Triangle

```elixir
defmodule PT do
  def generate(1), do: [[1]]
  
  def generate(num) do
    Enum.reverse(do_generate(num, [[1,1], [1]]))
  end

  defp do_generate(2, acc), do: acc

  defp do_generate(num, [head | _] = acc) do
    row = [0 | head]
    next_row = Enum.reduce(0..length(row) - 1, [], fn i, acc ->
      [Enum.at(row, i) + Enum.at(row, i + 1, 0) | acc]
    end)

    do_generate(num - 1, [next_row | acc])
  end
end

PT.generate(5)
```

## 303. Range Sum Query - Immutable

```elixir
defmodule RSQI do
  use Agent
  
  def init_(nums) do
    prefix_values = 
      (0..length(nums) - 1) 
      |> Enum.reduce([0], fn i, acc ->
        [Enum.at(nums, i) + List.first(acc) | acc]
      end) 
      |> Enum.reverse()
      |> List.delete_at(0)
      
    Agent.start_link(fn -> prefix_values end, name: __MODULE__)
  end

  def sum_range(0, right) do
    list = Agent.get(__MODULE__, & &1)
    Enum.at(list, right)
  end
  
  def sum_range(left, right) do
    list = Agent.get(__MODULE__, & &1)
    Enum.at(list, right) - Enum.at(list, left - 1)
  end
end

RSQI.init_([-2, 0, 3, -5, 2, -1])
RSQI.sum_range(0, 2)

RSQI.init_([-1])
RSQI.sum_range(0, 2)
```

## 338. Counting Bits

```elixir
0..5
|> Enum.reduce([], fn i, acc ->
  [i |> Integer.digits(2) |> Enum.sum() | acc]
end)
|> Enum.reverse()

# [0,1,1,2,1,2]
```

## 876. Middle of the Linked List

```elixir
defmodule MLL do
  def middle_node(head) do
    do_middle_node(head, head)
  end

  defp do_middle_node(slow, %ListNode{next: %ListNode{}} = fast) do
    do_middle_node(slow.next, fast.next.next)
  end

  defp do_middle_node(slow, _), do: slow
end
```

## 234. Palindrome Linked List

```elixir
defmodule PLL do
  def is_palindrome(head) do
    reverse(head, nil) == head
  end

  defp reverse(nil, acc), do: acc
  
  defp reverse(list_node, acc) do
    reverse(list_node.next, Map.put(list_node, :next, acc))
  end
end

head = %{
  val: 1,
  next: %{
    val: 2,
    next: %{val: 2, next: %{val: 1, next: nil}}
  }
}

PLL.is_palindrome(head)
```

## 203. Remove Linked List

```elixir
defmodule RLL do
  def remove_elements(head, val) do
    do_remove_elements(head, val, nil)
  end

  defp do_remove_elements(nil, _val, acc), do: reverse(acc, nil)
  
  defp do_remove_elements(head, val, acc) do
    if head.val == val do
      do_remove_elements(head.next, val, acc)
    else
      do_remove_elements(head.next, val, Map.put(head, :next, acc))
    end
  end

  defp reverse(nil, acc), do: acc
  
  defp reverse(head, acc) do
    reverse(head.next, Map.put(head, :next, acc))
  end
end

head = %{
  val: 1,
  next: %{
    val: 2,
    next: %{
      val: 6,
      next: %{
        val: 3,
        next: %{
          val: 4,
          next: %{val: 5, next: %{val: 6, next: nil}}
        }
      }
    }
  }
}

RLL.remove_elements(head, 6)
# [1,2,3,4,5]
```

## 744. Find Smallest Letter Greater than Target

```elixir
defmodule FSLGT do
  def next_greatest_letter(letters, target) do
    Enum.reduce_while(letters, target, fn letter, _acc ->
      if letter > target do
        {:halt, letter}
      else
        {:cont, List.first(letters)}
      end
    end) 
  end
end

letters = ["c", "f", "j"]
FSLGT.next_greatest_letter(letters, "a")
# "c"
letters = ["c", "f", "j"]
FSLGT.next_greatest_letter(letters, "c")
# "f"
# letters = ["x", "x", "y", "y"]
# FSLGT.next_greatest_letter(letters, "z")
# "x"
```

## 637. Average Levels in a Binary Tree

```elixir
defmodule ALBT do
  def average_of_levels(root) do
    bfs([root], [])
  end
  
  defp bfs([], averages), do: Enum.reverse(averages)
  
  defp bfs(level, averages) do
    level_average = Enum.reduce(level, 0, fn node, acc -> acc + node.val end) / length(level)
    
    next_level =
      Enum.flat_map(level, fn node ->
        Enum.reject([node.left, node.right], fn node ->
          is_nil(node)
        end)
      end)
    
    bfs(next_level, [level_average | averages])
  end
end

root = %{
  val: 3,
  left: %{val: 9, left: nil, right: nil},
  right: %{
    val: 20,
    left: %{val: 15, left: nil, right: nil},
    right: %{val: 7, left: nil, right: nil}
  }
}

ALBT.average_of_levels(root)
# [3.00000, 14.50000, 11.00000]
```

## 111. Minimum Depth of a Binary Tree

```elixir
defmodule MDBT do
  def min_depth(nil), do: 0
  
  def min_depth(root) do
    do_min_depth(root, 1)
  end

  defp do_min_depth(%{left: nil, right: nil}, depth), do: depth

  defp do_min_depth(%{left: left, right: nil}, depth) do
    do_min_depth(left, depth + 1)
  end

  defp do_min_depth(%{left: nil, right: right}, depth) do
    do_min_depth(right, depth + 1)
  end

  defp do_min_depth(node, depth) do
    min(do_min_depth(node.left, depth + 1), do_min_depth(node.right, depth + 1))
  end
end

root = %{
  val: 3,
  left: %{val: 9, left: nil, right: nil},
  right: %{
    val: 20,
    left: %{val: 15, left: nil, right: nil},
    right: %{val: 7, left: nil, right: nil}
  }
}


MDBT.min_depth(root)
# 2

root = %{
  val: 2,
  left: nil,
  right: %{
    val: 3,
    left: nil,
    right: %{
      val: 4,
      left: nil,
      right: %{
        val: 5,
        left: nil,
        right: %{val: 6, left: nil, right: nil}
      }
    }
  }
}

MDBT.min_depth(root)
# 5
```

## 100. Same Tree

```elixir
defmodule ST do
  def is_same_tree(nil, nil), do: true

  def is_same_tree(%{}, nil), do: false

  def is_same_tree(nil, %{}), do: false
  
  def is_same_tree(p, q) do
    p.val == q.val and is_same_tree(p.left, q.left) and is_same_tree(p.right, q.right)
  end
end

p = %{
  val: 1,
  left: %{val: 2, left: nil, right: nil},
  right: %{val: 3, left: nil, right: nil}
}

q = %{
  val: 1,
  left: %{val: 2, left: nil, right: nil},
  right: %{val: 3, left: nil, right: nil}
}

ST.is_same_tree(p, q)
# true
```

## 112. Path Sum

```elixir
defmodule PS do
  def has_path_sum(nil, _target_sum), do: false
  
  def has_path_sum(root, target_sum) do
    dfs(root, target_sum, 0)
  end
  
  defp dfs(nil, _target_sum, _acc), do: false
  
  defp dfs(node, target_sum, acc) do
    current_sum = acc + node.val
    
    if node.left == nil and node.right == nil do
      current_sum == target_sum
    else
      dfs(node.left, target_sum, current_sum) or dfs(node.right, target_sum, current_sum)
    end
  end
end

root = %{
  val: 5,
  left: %{
    val: 4,
    left: %{
      val: 11,
      left: %{val: 7, left: nil, right: nil},
      right: %{val: 2, left: nil, right: nil}
    },
    right: nil
  },
  right: %{
    val: 8,
    left: %{val: 13, left: nil, right: nil},
    right: %{
      val: 4,
      left: nil,
      right: %{val: 1, left: nil, right: nil}
    }
  }
}

PS.has_path_sum(root, 22)
# true
```

## 617. Merge Two Binary Trees

```elixir
defmodule MTBT do
  def merge_trees(root1, root2) do
    dfs(root1, root2)
  end

  defp dfs(nil, nil), do: nil
  
  defp dfs(nil, root2), do: root2

  defp dfs(root1, nil), do: root1

  defp dfs(root1, root2) do
    %{
      left: dfs(root1.left, root2.left), 
      right: dfs(root1.right, root2.right), 
      val: root1.val + root2.val
    }
  end
end

root1 = %{
  val: 1,
  left: %{
    val: 3,
    left: %{val: 5, left: nil, right: nil},
    right: nil
  },
  right: %{val: 2, left: nil, right: nil}
}

root2 = %{
  val: 2,
  left: %{
    val: 1,
    left: nil,
    right: %{val: 4, left: nil, right: nil}
  },
  right: %{
    val: 3,
    left: nil,
    right: %{val: 7, left: nil, right: nil}
  }
}

MTBT.merge_trees(root1, root2)
# [3,4,5,5,4,null,7]
```

## 572. Subtree of Another Tree

```elixir
defmodule SAT do
  def is_subtree(nil, nil), do: true

  def is_subtree(nil, %{}), do: false

  def is_subtree(root, sub_root) do
    if same_tree?(root, sub_root) do
      true
    else
      is_subtree(root.left, sub_root) or is_subtree(root.right, sub_root)
    end
  end

  defp same_tree?(nil, nil), do: true

  defp same_tree?(%{}, nil), do: false

  defp same_tree?(nil, %{}), do: false
  
  defp same_tree?(p, q) do
    p.val == q.val and same_tree?(p.left, q.left) and same_tree?(p.right, q.right)
  end
end

root = %{
  val: 3,
  left: %{
    val: 4,
    left: %{val: 1, left: nil, right: nil},
    right: %{val: 2, left: nil, right: nil}
  },
  right: %{val: 5, left: nil, right: nil}
}

sub_root = %{
  val: 4,
  left: %{val: 1, left: nil, right: nil},
  right: %{val: 2, left: nil, right: nil}
}


SAT.is_subtree(root, sub_root)
```

## 977. Squares of a Sorted Array

```elixir
nums = [-4, -1, 0, 3, 10]

nums |> Enum.map(fn n -> n * n end) |> Enum.sort()
# [0,1,9,16,100]
```

## 844. Backspace String Comparison

```elixir
defmodule BSC do
  def backspace_compare(s, t) do
    do_backspace(s) == do_backspace(t)
  end

  defp do_backspace(string) do
    string
    |> String.graphemes()
    |> Enum.reduce([], fn 
      "#", [_ | tail] -> tail
      "#", [] -> []
      c, acc -> [c | acc]
    end)
  end
end

# s = "ab#c"
# t = "ad#c"
# true

# s = "ab#c"
# t = "ad#c"
# true

# s = "ab##"
# t = "c#d#"
# true

s = "xywrrmp"
t = "xywrrmu#p"
# true

BSC.backspace_compare(s, t)
```

## 2022. Convert 1D Array in 2D Array

```elixir
original = [1,2,3,4]
m = 2
n = 2
# [[1,2],[3,4]]

# original = [1,2,3]
# m = 1
# n = 3
# [[1,2,3]]

# original = [1,2]
# m = 1
# n = 1
# []

if length(original) != (m * n) do
  []
else
  Enum.chunk_every(original, n)
end
```

## 392. Is Subsequence

```elixir
s = "abc"
t = "ahbgdc"
# true

s = "axc"
t = "ahbgdc"
# false

t
|> String.graphemes()
|> Enum.reduce_while(String.graphemes(s), fn
  _, [] -> {:halt, []}
  <<c>>, [<<c>> | tail] -> {:cont, tail}
  _, acc -> {:cont, acc}
end)
|> then(fn result ->
  result == []
end)
```

## 257. Binary Tree Paths

```elixir
defmodule BTP do
  def binary_tree_paths(root) do
    dfs(root, [])
  end

  defp dfs(%{left: nil, right: nil, val: val}, acc) do
    path = Enum.reverse([val | acc]) |> Enum.join("->")
    [path]
  end 

  defp dfs(%{left: nil, right: right, val: val}, acc) do
    dfs(right, [val | acc])
  end

  defp dfs(%{left: left, right: nil, val: val}, acc) do
    dfs(left, [val | acc])
  end

  defp dfs(%{left: left, right: right, val: val}, acc) do
    dfs(left, [val | acc]) ++ dfs(right, [val | acc])
  end
end

root = %{
  val: 1,
  left: %{
    val: 2,
    left: nil,
    right: %{val: 5, left: nil, right: nil}
  },
  right: %{val: 3, left: nil, right: nil}
}

BTP.binary_tree_paths(root)
```

## 643. Maximum Average Subarray 1

```elixir
nums = [1, 12, -5, -6, 50, 3] 
k = 4
# 12.75000

initial_sum = Enum.take(nums, k) |> Enum.sum()
    
nums
|> Enum.drop(k)
|> Enum.zip(nums)
|> Enum.reduce({initial_sum, initial_sum}, fn {add, remove}, {current_sum, max_sum} ->
  new_sum = current_sum + add - remove
  {new_sum, max(new_sum, max_sum)}
end)
|> elem(1)
|> Kernel./(k)
```

## 287. Find the Duplicate Number

```elixir
nums = [1,3,4,2,2]
# 2

nums 
|> Enum.frequencies() 
|> Enum.sort_by(fn {_k, v} -> v end, :desc) 
|> List.first() 
|> elem(0)
```

## 442. Find all Duplicates in an Array

```elixir
nums = [4,3,2,7,8,2,3,1]
# [2,3]

nums
|> Enum.frequencies()
|> Enum.filter(fn {_k, v} -> v == 2 end)
|> Enum.reduce([], fn {k, _v}, acc ->
  [k | acc]
end)
|> Enum.reverse()
```

## 54. Spiral Matrix

```elixir
defmodule SM do
  def spiral_order(matrix) do
    left = 0
    right = matrix |> List.first() |> length()
    top = 0
    bottom = length(matrix)

    do_spiral_order(matrix, [], left, right, top, bottom)
  end

  defp do_spiral_order(_matrix, acc, left, right, top, bottom)
     when left >= right or top >= bottom do
    acc
  end

  defp do_spiral_order(matrix, acc, left, right, top, bottom) do
    acc = acc ++ traverse_row(matrix, top, left, right - 1, 1)
    acc = acc ++ traverse_col(matrix, right - 1, top + 1, bottom - 1, 1)
  
    acc = if top < bottom - 1 do
      acc ++ traverse_row(matrix, bottom - 1, right - 2, left, -1)
    else
      acc
    end
  
    acc = if left < right - 1 do
      acc ++ traverse_col(matrix, left, bottom - 2, top + 1, -1)
    else
      acc
    end
  
    do_spiral_order(matrix, acc, left + 1, right - 1, top + 1, bottom - 1)
  end

  defp traverse_row(matrix, row, from_col, to_col, step) do
    for col <- from_col..to_col//step, do: get_elem(matrix, row, col)
  end

  defp traverse_col(matrix, col, from_row, to_row, step) do
    for row <- from_row..to_row//step, do: get_elem(matrix, row, col)
  end

  defp get_elem(matrix, row, col), do: Enum.at(matrix, row) |> Enum.at(col)
end


matrix = [[1,2,3],[4,5,6],[7,8,9]]
# [1,2,3,6,9,8,7,4,5]

matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
# [1,2,3,4,8,12,11,10,9,5,6,7]

SM.spiral_order(matrix)
```

## 3522. Calculate Score After Performing Instructions

```elixir
defmodule CSAPI do
  def calculate_score(instructions, values) do
    do_calculate_score(instructions, values, 0, 0, MapSet.new())
  end
  
  defp do_calculate_score(instructions, _values, i, score, _visited) when i < 0 or i >= length(instructions) do
    score
  end
  
  defp do_calculate_score(instructions, values, i, score, visited) do
    if MapSet.member?(visited, i) do
      score
    else
      visited = MapSet.put(visited, i)
      
      case Enum.at(instructions, i) do
        "add" ->
          new_score = score + Enum.at(values, i)
          do_calculate_score(instructions, values, i + 1, new_score, visited)
        
        "jump" ->
          new_i = i + Enum.at(values, i)
          do_calculate_score(instructions, values, new_i, score, visited)
      end
    end
  end
end

instructions = ["jump","add","add","jump","add","jump"]
values = [2,1,3,1,-2,-3]

CSAPI.calculate_score(instructions, values)
# 1
```

## 56. Merge Intervals

```elixir
defmodule MI do
  def merge(intervals) do
    intervals
    |> Enum.sort_by(fn [start, _end] -> start end)
    |> do_merge([])
    |> Enum.reverse()
  end

  defp do_merge([], acc), do: acc

  defp do_merge([[head_one,  head_two] | tail], 
                [[acc_one, acc_two] | acc_tail]) when head_one <= acc_two do
    merged_el = [acc_one, max(head_two, acc_two)]
    do_merge(tail, [merged_el | acc_tail])
  end

  defp do_merge([head | tail], acc) do
    do_merge(tail, [head | acc])
  end
end

intervals = [[1,3],[2,6],[8,10],[15,18]]
MI.merge(intervals)
# [[1,6],[8,10],[15,18]]
```
